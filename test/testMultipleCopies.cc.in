//////////////////////////////////////////////////////////////////////////
// testMultipleCopies.cc.in
//
// garren@fnal.gov, January 2008
// Multiple events in memory at the same time
// run with valgrind or some other leak checker
//////////////////////////////////////////////////////////////////////////
//

#include <fstream>

#include "HepMC/IO_Ascii.h"
#include "HepMC/IO_ExtendedAscii.h"
#include "HepMC/GenEvent.h"
#include "HepMC/CompareGenEvent.h"

// define methods and classes used by this test
#include "IsGoodEvent.h"

int main() { 
    // declare an input strategy
    HepMC::IO_Ascii ascii_in("@srcdir@/testHepMC.input",std::ios::in);
    // declare another input strategy 
    HepMC::IO_ExtendedAscii ascii_ext("@srcdir@/testHepMCExtended.input",std::ios::in);
    // use output file
    std::ofstream os( "testMultipleCopies.out" );
    std::ofstream out1( "testMultipleOriginals.dat" );
    std::ofstream out2( "testMultipleCopies1.dat" );
    std::ofstream out3( "testMultipleCopies2.dat" );
    // declare an instance of the event selection predicate
    IsGoodEvent is_good_event;

    //........................................EVENT LOOP
    int icount=0;
    int num_good_events=0;
    int icnt;
    HepMC::GenEvent* evt1 = ascii_in.read_next_event();
    HepMC::GenEvent* evt2 = ascii_ext.read_next_event();
    HepMC::GenEvent* evt3 = ascii_in.read_next_event();

    while ( evt1 && evt2 ) {
	icount++;
	if ( icount%50==1 ) os << "Processing Event Number " << icount
			       << " stream 1 # " << evt1->event_number() 
			       << " stream 2 # " << evt2->event_number() 
			       << std::endl;

	if ( is_good_event(evt1) ) {
	
	    os << "good event in stream 1 # " 
	       << evt1->event_number() << std::endl;
	    evt1->print(out1);
	    ++num_good_events;
	    HepMC::GenEvent ec = (*evt1);
	    ec.print(out3);
	    icnt=0;
	    for ( HepMC::GenEvent::particle_const_iterator p1 =  ec.particles_begin();
        	  p1 !=  ec.particles_end(); ++p1 ) {
		  ++icnt;
		os << "particle " << icnt << " barcode " <<(*p1)->barcode() << std::endl;
	    }
	    HepMC::GenEvent* evt4 = new HepMC::GenEvent(*evt1);
	    evt4->print(out2);
 	    if( !compareGenEvent(evt1,evt4) ) { return -1; }
            delete evt4;
	}
	if ( is_good_event(evt2) ) {
	    os << "good event in stream 2 # " 
	       << evt2->event_number() << std::endl;
	    evt2->print(out1);
	    ++num_good_events;
	    HepMC::GenEvent ec = (*evt2);
	    ec.print(out3);
	    icnt=0;
	    for ( HepMC::GenEvent::particle_const_iterator p1 =  ec.particles_begin();
        	  p1 !=  ec.particles_end(); ++p1 ) {
		  ++icnt;
		os << "particle " << icnt << " barcode " <<(*p1)->barcode() << std::endl;
	    }
	    HepMC::GenEvent* evt4 = new HepMC::GenEvent(*evt2);
 	    evt4->print(out2);
	    if( !compareGenEvent(evt2,evt4) ) { return -2; }
            delete evt4;
	}
	
	// clean up and get next events
	delete evt1;
        delete evt2;
	ascii_in >> evt1;
	ascii_ext >> evt2;
    }
    // might have either evt1 or evt2 still in memory, cleanup here
    delete evt1;
    delete evt2;
    delete evt3;
    
    //........................................PRINT RESULT
    os << std::endl;
    os << num_good_events << " out of " << icount 
       << " processed events passed the cuts. Finished." << std::endl;

    return 0;
}
